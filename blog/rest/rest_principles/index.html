<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding REST API Principles: A Comprehensive Guide for Developers | Priyanka Yelluru</title>
<meta name=keywords content="REST,API,Interview,Web Development,HTTP"><meta name=description content="A deep dive into REST API principles with practical examples and best practices."><meta name=author content><link rel=canonical href=https://priya.se/blog/rest/rest_principles/><link crossorigin=anonymous href=/assets/css/stylesheet.51e815373e8719f87994fad2043c4a754a45c215e74d4c37660ea05e87cce8ca.css integrity="sha256-UegVNz6HGfh5lPrSBDxKdUpFwhXnTUw3Zg6gXofM6Mo=" rel="preload stylesheet" as=style><link rel=icon href=https://priya.se/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://priya.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://priya.se/favicon-32x32.png><link rel=apple-touch-icon href=https://priya.se/apple-touch-icon.png><link rel=mask-icon href=https://priya.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://priya.se/blog/rest/rest_principles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://priya.se/blog/rest/rest_principles/"><meta property="og:site_name" content="Priyanka Yelluru"><meta property="og:title" content="Understanding REST API Principles: A Comprehensive Guide for Developers"><meta property="og:description" content="A deep dive into REST API principles with practical examples and best practices."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-02-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-01T00:00:00+00:00"><meta property="article:tag" content="REST"><meta property="article:tag" content="API"><meta property="article:tag" content="Interview"><meta property="article:tag" content="Web Development"><meta property="article:tag" content="HTTP"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding REST API Principles: A Comprehensive Guide for Developers"><meta name=twitter:description content="A deep dive into REST API principles with practical examples and best practices."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://priya.se/blog/"},{"@type":"ListItem","position":2,"name":"Understanding REST API Principles: A Comprehensive Guide for Developers","item":"https://priya.se/blog/rest/rest_principles/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding REST API Principles: A Comprehensive Guide for Developers","name":"Understanding REST API Principles: A Comprehensive Guide for Developers","description":"A deep dive into REST API principles with practical examples and best practices.","keywords":["REST","API","Interview","Web Development","HTTP"],"articleBody":"REST (Representational State Transfer) is one of the most widely adopted architectural styles for designing networked applications. Whether you’re preparing for a technical interview or looking to improve your API design skills, understanding REST API principles is essential. In this post, we’ll break down the core concepts of REST, discuss its fundamental constraints, provide practical examples, and summarize the overall ideas to reinforce your learning.\nWhat is REST? REST is an architectural style introduced by Roy Fielding in his doctoral dissertation. It is not a protocol but a set of constraints that, when applied to a networked system (typically web services), enable scalability, simplicity, and reliability. RESTful APIs leverage HTTP methods, URIs, and standard data formats like JSON or XML to facilitate communication between clients and servers.\nCore REST Principles To fully understand REST, it is important to grasp its six guiding principles:\n1. Client-Server Architecture Definition: Separates the user interface concerns from data storage concerns. Benefit: Improves portability of the user interface across different platforms and improves scalability by simplifying server components. Example: A mobile app (client) communicates with a remote server to fetch data rather than embedding data management logic on the device. 2. Statelessness Definition: Each request from the client to the server must contain all of the information needed to understand and process the request. Benefit: Enhances scalability since the server does not need to store session information between requests. Example: When a client makes a GET request to /users/123, the server processes the request solely based on that request data without needing prior context. 3. Cacheability Definition: Responses must define themselves as cacheable or not, to prevent clients from reusing stale or inappropriate data in future requests. Benefit: Reduces client-server interactions, which enhances performance and scalability. Example: A GET request for a static resource like /products may be cached by the client or an intermediary proxy. 4. Uniform Interface Definition: A standardized way of interacting with resources via a consistent set of rules. Benefits: Simplifies and decouples the architecture, enabling each part to evolve independently. Components of a Uniform Interface: Resource Identification: Each resource is identified by a unique URI (e.g., /books/1). Resource Manipulation Through Representations: Clients interact with a resource by using its representation (typically JSON or XML). Self-descriptive Messages: Each message includes enough information to describe how to process the message. Hypermedia as the Engine of Application State (HATEOAS): Clients interact with the application entirely through hypermedia provided dynamically by server responses. 5. Layered System Definition: The client does not need to know whether it is connected directly to the end server or through an intermediary. Benefit: Enhances system scalability and security by allowing load balancing, caching, and proxy servers. Example: An API gateway or reverse proxy can manage requests between the client and various microservices without exposing internal architecture. 6. Code on Demand (Optional) Definition: Servers can temporarily extend or customize client functionality by transferring executable code. Benefit: Adds flexibility, though it is rarely used in practice. Example: Serving JavaScript to enhance client-side interactivity. HTTP Methods and CRUD Operations A well-designed RESTful API maps standard HTTP methods to CRUD (Create, Read, Update, Delete) operations:\nGET: Retrieve a resource.\nExample: GET /users/123 retrieves user 123’s data.\nPOST: Create a new resource.\nExample: POST /users creates a new user with data provided in the request body.\nPUT: Update an existing resource.\nExample: PUT /users/123 updates user 123’s details with new data.\nDELETE: Remove a resource.\nExample: DELETE /users/123 deletes user 123 from the system.\nThese mappings help in creating an intuitive and predictable API design.\nPractical Example: Building a Simple Task Management API Imagine you are designing a simple RESTful API to manage tasks in a to-do list application. Here’s how you might map out the endpoints:\nList All Tasks:\nRequest: GET /tasks\nResponse: JSON array of tasks.\nCreate a New Task:\nRequest: POST /tasks\nRequest Body:\n{ \"title\": \"Buy groceries\", \"description\": \"Milk, Bread, Eggs\", \"status\": \"pending\" } Response: The created task object with a unique id.\nRetrieve a Specific Task:\nRequest: GET /tasks/{id} Response: JSON object for the task with the given id. Update a Task:\nRequest: PUT /tasks/{id}\nRequest Body:\n{ \"title\": \"Buy groceries\", \"description\": \"Milk, Bread, Eggs, and Cheese\", \"status\": \"in-progress\" } Response: The updated task object.\nDelete a Task:\nRequest: DELETE /tasks/{id} Response: Confirmation message or status code indicating deletion. Using cURL for Testing Here are a couple of cURL examples to interact with your API:\nCreating a New Task curl -X POST http://api.example.com/tasks \\ -H \"Content-Type: application/json\" \\ -d '{ \"title\": \"Buy groceries\", \"description\": \"Milk, Bread, Eggs\", \"status\": \"pending\" }' Fetching a Task curl -X GET http://api.example.com/tasks/1 These examples illustrate how you can interact with a RESTful API using HTTP methods that map to CRUD operations.\nBest Practices for REST API Design Consistent Naming Conventions: Use clear and consistent naming for endpoints (e.g., use plural nouns like /users).\nVersioning: Maintain API versions (e.g., /v1/users) to handle future changes without breaking existing integrations. Error Handling: Use standard HTTP status codes and provide informative error messages to help clients diagnose issues. Security: Implement authentication (e.g., OAuth, JWT) and authorization to protect sensitive data. Documentation: Provide clear, up-to-date documentation (e.g., using tools like Swagger or Postman collections) so that developers know how to use your API. Summary In this article, we covered the foundational principles of RESTful API design:\nClient-Server Architecture: Decoupling the client from the server. Statelessness: Ensuring each request is independent. Cacheability: Enhancing performance with cacheable responses. Uniform Interface: Standardizing interactions through HTTP. Layered System: Allowing intermediaries to improve scalability and security. Code on Demand: An optional principle for extending client functionality. We also explored how to map HTTP methods to CRUD operations and provided a practical example of building a simple task management API. ","wordCount":"955","inLanguage":"en","datePublished":"2024-02-01T00:00:00Z","dateModified":"2024-02-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://priya.se/blog/rest/rest_principles/"},"publisher":{"@type":"Organization","name":"Priyanka Yelluru","logo":{"@type":"ImageObject","url":"https://priya.se/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://priya.se/ accesskey=h title="Priyanka Yelluru (Alt + H)">Priyanka Yelluru</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://priya.se/ title=Home><span>Home</span></a></li><li><a href=https://priya.se/about title=About><span>About</span></a></li><li><a href=https://priya.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://priya.se/now title=Now><span>Now</span></a></li><li><a href=https://priya.se/portfolio title=Portfolio><span>Portfolio</span></a></li><li><a href=https://priya.se/contact title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Understanding REST API Principles: A Comprehensive Guide for Developers</h1><div class=post-description>A deep dive into REST API principles with practical examples and best practices.</div><div class=post-meta><span title='2024-02-01 00:00:00 +0000 UTC'>February 1, 2024</span></div></header><div class=post-content><p>REST (Representational State Transfer) is one of the most widely adopted architectural styles for designing networked applications. Whether you&rsquo;re preparing for a technical interview or looking to improve your API design skills, understanding REST API principles is essential. In this post, we&rsquo;ll break down the core concepts of REST, discuss its fundamental constraints, provide practical examples, and summarize the overall ideas to reinforce your learning.</p><h2 id=what-is-rest>What is REST?<a hidden class=anchor aria-hidden=true href=#what-is-rest>#</a></h2><p><img alt="Alt rest principles" loading=lazy src=/images/Characteristics-of-REST.png></p><p>REST is an architectural style introduced by Roy Fielding in his doctoral dissertation. It is not a protocol but a set of constraints that, when applied to a networked system (typically web services), enable scalability, simplicity, and reliability. RESTful APIs leverage HTTP methods, URIs, and standard data formats like JSON or XML to facilitate communication between clients and servers.</p><h2 id=core-rest-principles>Core REST Principles<a hidden class=anchor aria-hidden=true href=#core-rest-principles>#</a></h2><p>To fully understand REST, it is important to grasp its six guiding principles:</p><h3 id=1-client-server-architecture>1. Client-Server Architecture<a hidden class=anchor aria-hidden=true href=#1-client-server-architecture>#</a></h3><ul><li><strong>Definition:</strong> Separates the user interface concerns from data storage concerns.</li><li><strong>Benefit:</strong> Improves portability of the user interface across different platforms and improves scalability by simplifying server components.</li><li><strong>Example:</strong> A mobile app (client) communicates with a remote server to fetch data rather than embedding data management logic on the device.</li></ul><h3 id=2-statelessness>2. Statelessness<a hidden class=anchor aria-hidden=true href=#2-statelessness>#</a></h3><ul><li><strong>Definition:</strong> Each request from the client to the server must contain all of the information needed to understand and process the request.</li><li><strong>Benefit:</strong> Enhances scalability since the server does not need to store session information between requests.</li><li><strong>Example:</strong> When a client makes a GET request to <code>/users/123</code>, the server processes the request solely based on that request data without needing prior context.</li></ul><h3 id=3-cacheability>3. Cacheability<a hidden class=anchor aria-hidden=true href=#3-cacheability>#</a></h3><ul><li><strong>Definition:</strong> Responses must define themselves as cacheable or not, to prevent clients from reusing stale or inappropriate data in future requests.</li><li><strong>Benefit:</strong> Reduces client-server interactions, which enhances performance and scalability.</li><li><strong>Example:</strong> A GET request for a static resource like <code>/products</code> may be cached by the client or an intermediary proxy.</li></ul><h3 id=4-uniform-interface>4. Uniform Interface<a hidden class=anchor aria-hidden=true href=#4-uniform-interface>#</a></h3><ul><li><strong>Definition:</strong> A standardized way of interacting with resources via a consistent set of rules.</li><li><strong>Benefits:</strong> Simplifies and decouples the architecture, enabling each part to evolve independently.</li><li><strong>Components of a Uniform Interface:</strong><ul><li><strong>Resource Identification:</strong> Each resource is identified by a unique URI (e.g., <code>/books/1</code>).</li><li><strong>Resource Manipulation Through Representations:</strong> Clients interact with a resource by using its representation (typically JSON or XML).</li><li><strong>Self-descriptive Messages:</strong> Each message includes enough information to describe how to process the message.</li><li><strong>Hypermedia as the Engine of Application State (HATEOAS):</strong> Clients interact with the application entirely through hypermedia provided dynamically by server responses.</li></ul></li></ul><h3 id=5-layered-system>5. Layered System<a hidden class=anchor aria-hidden=true href=#5-layered-system>#</a></h3><ul><li><strong>Definition:</strong> The client does not need to know whether it is connected directly to the end server or through an intermediary.</li><li><strong>Benefit:</strong> Enhances system scalability and security by allowing load balancing, caching, and proxy servers.</li><li><strong>Example:</strong> An API gateway or reverse proxy can manage requests between the client and various microservices without exposing internal architecture.</li></ul><h3 id=6-code-on-demand-optional>6. Code on Demand (Optional)<a hidden class=anchor aria-hidden=true href=#6-code-on-demand-optional>#</a></h3><ul><li><strong>Definition:</strong> Servers can temporarily extend or customize client functionality by transferring executable code.</li><li><strong>Benefit:</strong> Adds flexibility, though it is rarely used in practice.</li><li><strong>Example:</strong> Serving JavaScript to enhance client-side interactivity.</li></ul><h2 id=http-methods-and-crud-operations>HTTP Methods and CRUD Operations<a hidden class=anchor aria-hidden=true href=#http-methods-and-crud-operations>#</a></h2><p>A well-designed RESTful API maps standard HTTP methods to CRUD (Create, Read, Update, Delete) operations:</p><ul><li><p><strong>GET:</strong> Retrieve a resource.<br><em>Example:</em> <code>GET /users/123</code> retrieves user 123&rsquo;s data.</p></li><li><p><strong>POST:</strong> Create a new resource.<br><em>Example:</em> <code>POST /users</code> creates a new user with data provided in the request body.</p></li><li><p><strong>PUT:</strong> Update an existing resource.<br><em>Example:</em> <code>PUT /users/123</code> updates user 123’s details with new data.</p></li><li><p><strong>DELETE:</strong> Remove a resource.<br><em>Example:</em> <code>DELETE /users/123</code> deletes user 123 from the system.</p></li></ul><p>These mappings help in creating an intuitive and predictable API design.</p><h2 id=practical-example-building-a-simple-task-management-api>Practical Example: Building a Simple Task Management API<a hidden class=anchor aria-hidden=true href=#practical-example-building-a-simple-task-management-api>#</a></h2><p>Imagine you are designing a simple RESTful API to manage tasks in a to-do list application. Here’s how you might map out the endpoints:</p><ul><li><p><strong>List All Tasks:</strong><br><strong>Request:</strong> <code>GET /tasks</code><br><strong>Response:</strong> JSON array of tasks.</p></li><li><p><strong>Create a New Task:</strong><br><strong>Request:</strong> <code>POST /tasks</code><br><strong>Request Body:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;title&#34;</span>: <span style=color:#e6db74>&#34;Buy groceries&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;description&#34;</span>: <span style=color:#e6db74>&#34;Milk, Bread, Eggs&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;status&#34;</span>: <span style=color:#e6db74>&#34;pending&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p><strong>Response</strong>: The created task object with a unique id.</p><ul><li><p><strong>Retrieve a Specific Task:</strong></p><ul><li><strong>Request:</strong> <code>GET /tasks/{id}</code></li><li><strong>Response:</strong> JSON object for the task with the given id.</li></ul></li><li><p><strong>Update a Task:</strong></p><ul><li><p><strong>Request:</strong> <code>PUT /tasks/{id}</code></p></li><li><p><strong>Request Body:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;title&#34;</span>: <span style=color:#e6db74>&#34;Buy groceries&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;description&#34;</span>: <span style=color:#e6db74>&#34;Milk, Bread, Eggs, and Cheese&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;status&#34;</span>: <span style=color:#e6db74>&#34;in-progress&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>Response:</strong> The updated task object.</p></li></ul></li><li><p><strong>Delete a Task:</strong></p><ul><li><strong>Request:</strong> <code>DELETE /tasks/{id}</code></li><li><strong>Response:</strong> Confirmation message or status code indicating deletion.</li></ul></li></ul><h2 id=using-curl-for-testing>Using cURL for Testing<a hidden class=anchor aria-hidden=true href=#using-curl-for-testing>#</a></h2><p>Here are a couple of cURL examples to interact with your API:</p><h3 id=creating-a-new-task>Creating a New Task<a hidden class=anchor aria-hidden=true href=#creating-a-new-task>#</a></h3><pre tabindex=0><code>curl -X POST http://api.example.com/tasks \
     -H &#34;Content-Type: application/json&#34; \
     -d &#39;{
           &#34;title&#34;: &#34;Buy groceries&#34;,
           &#34;description&#34;: &#34;Milk, Bread, Eggs&#34;,
           &#34;status&#34;: &#34;pending&#34;
         }&#39;
        
</code></pre><h3 id=fetching-a-task>Fetching a Task<a hidden class=anchor aria-hidden=true href=#fetching-a-task>#</a></h3><pre tabindex=0><code>curl -X GET http://api.example.com/tasks/1
</code></pre><p>These examples illustrate how you can interact with a RESTful API using HTTP methods that map to CRUD operations.</p><h2 id=best-practices-for-rest-api-design>Best Practices for REST API Design<a hidden class=anchor aria-hidden=true href=#best-practices-for-rest-api-design>#</a></h2><p>Consistent Naming Conventions: Use clear and consistent naming for endpoints (e.g., use plural nouns like /users).</p><ul><li>Versioning: Maintain API versions (e.g., /v1/users) to handle future changes without breaking existing integrations.</li><li>Error Handling: Use standard HTTP status codes and provide informative error messages to help clients diagnose issues.</li><li>Security: Implement authentication (e.g., OAuth, JWT) and authorization to protect sensitive data.</li><li>Documentation: Provide clear, up-to-date documentation (e.g., using tools like Swagger or Postman collections) so that developers know how to use your API.</li></ul><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>In this article, we covered the foundational principles of RESTful API design:</p><ul><li>Client-Server Architecture: Decoupling the client from the server.</li><li>Statelessness: Ensuring each request is independent.</li><li>Cacheability: Enhancing performance with cacheable responses.</li><li>Uniform Interface: Standardizing interactions through HTTP.</li><li>Layered System: Allowing intermediaries to improve scalability and security.</li><li>Code on Demand: An optional principle for extending client functionality.</li><li>We also explored how to map HTTP methods to CRUD operations and provided a practical example of building a simple task management API.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://priya.se/tags/rest/>REST</a></li><li><a href=https://priya.se/tags/api/>API</a></li><li><a href=https://priya.se/tags/interview/>Interview</a></li><li><a href=https://priya.se/tags/web-development/>Web Development</a></li><li><a href=https://priya.se/tags/http/>HTTP</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://priya.se/>Priyanka Yelluru</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>