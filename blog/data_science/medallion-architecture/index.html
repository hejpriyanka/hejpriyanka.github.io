<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding Medallion Architecture | Priyanka Yelluru</title>
<meta name=keywords content="Medallion Architecture,Data Lakehouse,Data Engineering,ETL,Data Quality,Hugo Blog"><meta name=description content="An in-depth look at Medallion Architecture, its layers (Bronze, Silver, Gold), principles, and real-world use cases in modern data engineering."><meta name=author content><link rel=canonical href=https://priya.se/blog/data_science/medallion-architecture/><link crossorigin=anonymous href=/assets/css/stylesheet.51e815373e8719f87994fad2043c4a754a45c215e74d4c37660ea05e87cce8ca.css integrity="sha256-UegVNz6HGfh5lPrSBDxKdUpFwhXnTUw3Zg6gXofM6Mo=" rel="preload stylesheet" as=style><link rel=icon href=https://priya.se/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://priya.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://priya.se/favicon-32x32.png><link rel=apple-touch-icon href=https://priya.se/apple-touch-icon.png><link rel=mask-icon href=https://priya.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://priya.se/blog/data_science/medallion-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://priya.se/blog/data_science/medallion-architecture/"><meta property="og:site_name" content="Priyanka Yelluru"><meta property="og:title" content="Understanding Medallion Architecture"><meta property="og:description" content="An in-depth look at Medallion Architecture, its layers (Bronze, Silver, Gold), principles, and real-world use cases in modern data engineering."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-02-21T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-21T00:00:00+00:00"><meta property="article:tag" content="Medallion Architecture"><meta property="article:tag" content="Data Lakehouse"><meta property="article:tag" content="Data Engineering"><meta property="article:tag" content="ETL"><meta property="article:tag" content="Data Quality"><meta property="article:tag" content="Hugo Blog"><meta property="og:image" content="https://priya.se/images/medallion_arch.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://priya.se/images/medallion_arch.png"><meta name=twitter:title content="Understanding Medallion Architecture"><meta name=twitter:description content="An in-depth look at Medallion Architecture, its layers (Bronze, Silver, Gold), principles, and real-world use cases in modern data engineering."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://priya.se/blog/"},{"@type":"ListItem","position":2,"name":"Understanding Medallion Architecture","item":"https://priya.se/blog/data_science/medallion-architecture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding Medallion Architecture","name":"Understanding Medallion Architecture","description":"An in-depth look at Medallion Architecture, its layers (Bronze, Silver, Gold), principles, and real-world use cases in modern data engineering.","keywords":["Medallion Architecture","Data Lakehouse","Data Engineering","ETL","Data Quality","Hugo Blog"],"articleBody":"Understanding Medallion Architecture: A Comprehensive Guide In today’s data-driven world, organizations face the challenge of managing vast volumes of diverse data coming from multiple sources. The Medallion Architecture offers a structured way to tackle this challenge by organizing data into layered stages, gradually refining it from its raw form to a business-ready state. Often referred to as a multi-hop architecture, this pattern is especially popular in modern data lakehouse environments where the flexibility of a data lake meets the reliability of a data warehouse.\nIn this post, we will explore the key concepts of Medallion Architecture, explain each layer in detail, and discuss where and how it can be applied.\nWhat Is Medallion Architecture? Medallion Architecture is a data design pattern that organizes data processing into multiple, logical layers. The goal is to incrementally improve data quality and structure as data flows through these layers. The three primary layers are:\nBronze: Raw, unfiltered data. Silver: Cleansed and conformed data. Gold: Aggregated, business-level data ready for consumption. By separating the data processing pipeline into these layers, organizations can ensure robust data governance, maintain auditability, and support both exploratory analytics and mission-critical reporting.\nThe Layers of Medallion Architecture Bronze Layer: The Raw Data Zone The Bronze layer is the foundation of the Medallion Architecture. Here, data is ingested from various external sources and stored in its original, unaltered format. Key characteristics include:\nRaw Ingestion: Data is captured as-is (e.g., CSV files, JSON logs, streaming data). Metadata Enrichment: Additional columns, such as load timestamp, source ID, or processing status, are often added. Historical Archive: Since no major transformations are applied, this layer serves as a robust archive for data lineage and reprocessing. Example Use Case:\nA retail company collects transaction logs from multiple point-of-sale systems. These logs are loaded into the Bronze layer to preserve the exact state of the data as received, ensuring that every detail is available for auditing or troubleshooting.\nSilver Layer: Cleansing and Conforming Once raw data is stored, it needs to be cleaned and standardized. The Silver layer takes data from the Bronze layer and applies a series of transformations to:\nCleanse Data: Remove duplicates, filter out corrupt records, and handle missing values. Standardize Formats: Convert data into a consistent schema and format. Integrate Multiple Sources: Merge and reconcile data from different sources to create a unified view. Example Use Case:\nContinuing with the retail example, data from different stores is merged and cleansed in the Silver layer. Customer records are deduplicated, and inconsistencies (such as varying date formats) are resolved, resulting in a consistent view of transactions and customer interactions.\nSample Transformation Code (PySpark):\n# Read raw data from Bronze layer bronze_df = spark.read.format(\"delta\").load(\"/lake/bronze/transactions\") # Cleanse and standardize data for the Silver layer silver_df = bronze_df.filter(\"amount IS NOT NULL\") \\ .withColumn(\"transaction_date\", to_date(col(\"transaction_date\"), \"MM-dd-yyyy\")) \\ .dropDuplicates([\"transaction_id\"]) # Write the cleansed data to the Silver layer silver_df.write.format(\"delta\").mode(\"overwrite\").save(\"/lake/silver/transactions\") Gold Layer: Business-Ready Aggregated Data The final stage in the Medallion Architecture is the Gold layer, where data is further refined and optimized for direct business consumption. This layer focuses on:\nAggregation and Enrichment: Applying business logic, creating summary tables, and performing complex calculations. Optimized for Analytics: Data models in the Gold layer are often denormalized (e.g., star schema) for fast query performance. Tailored Views: The data is arranged to serve specific use cases like dashboards, reporting, and machine learning applications. Example Use Case:\nIn the retail scenario, the Gold layer could consist of sales summaries by region, time-period, or product category. Business users and analysts can directly query these tables to generate KPIs and performance reports without worrying about the underlying data complexities.\nSample Aggregation Code (SQL):\n-- Create a Gold table for aggregated sales metrics CREATE TABLE gold_sales_summary AS SELECT store_id, date(transaction_date) as sale_date, SUM(amount) as total_sales, COUNT(transaction_id) as transactions_count FROM silver.transactions GROUP BY store_id, date(transaction_date); Where Can Medallion Architecture Be Applied? Medallion Architecture is versatile and can be applied in various scenarios, including:\nData Lakehouses: Combining the scalability of data lakes with the reliability of data warehouses. Business Intelligence (BI): Providing clean, aggregated data for dashboards and reports. Machine Learning: Supplying high-quality, processed data to train robust ML models. Data Warehousing: Structuring ETL/ELT pipelines to support operational and analytical workloads. Data Governance: Enhancing traceability, auditability, and data quality across the organization. Key Principles and Benefits Incremental Data Refinement: Each layer builds upon the previous one, progressively enhancing data quality. Data Governance and Auditability: Keeping raw data intact in the Bronze layer ensures that data lineage and historical context are preserved. Scalability and Flexibility: Independent layers allow teams to scale processing and storage as needed, accommodating both batch and streaming data. Performance Optimization: The Gold layer’s design—often using star schema or other optimized data models—ensures fast query performance for business users. Single Source of Truth: Consistent data across layers builds trust and supports informed decision-making. Conclusion Medallion Architecture offers a clear and methodical framework for managing the data lifecycle—from raw ingestion to refined, business-ready analytics. By leveraging the Bronze, Silver, and Gold layers, organizations can ensure that data remains accurate, auditable, and scalable. Whether you’re building a data lakehouse, designing a data warehouse, or implementing a BI solution, adopting this layered approach can simplify your data pipelines and enhance overall data quality.\nHave you implemented Medallion Architecture in your projects?\nHappy Data Engineering!\n","wordCount":"883","inLanguage":"en","image":"https://priya.se/images/medallion_arch.png","datePublished":"2025-02-21T00:00:00Z","dateModified":"2025-02-21T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://priya.se/blog/data_science/medallion-architecture/"},"publisher":{"@type":"Organization","name":"Priyanka Yelluru","logo":{"@type":"ImageObject","url":"https://priya.se/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://priya.se/ accesskey=h title="Priyanka Yelluru (Alt + H)">Priyanka Yelluru</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://priya.se/ title=Home><span>Home</span></a></li><li><a href=https://priya.se/about title=About><span>About</span></a></li><li><a href=https://priya.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://priya.se/now title=Now><span>Now</span></a></li><li><a href=https://priya.se/portfolio title=Portfolio><span>Portfolio</span></a></li><li><a href=https://priya.se/contact title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Understanding Medallion Architecture</h1><div class=post-description>An in-depth look at Medallion Architecture, its layers (Bronze, Silver, Gold), principles, and real-world use cases in modern data engineering.</div><div class=post-meta><span title='2025-02-21 00:00:00 +0000 UTC'>February 21, 2025</span></div></header><figure class=entry-cover><img loading=eager src=https://priya.se/images/medallion_arch.png alt></figure><div class=post-content><h1 id=understanding-medallion-architecture-a-comprehensive-guide>Understanding Medallion Architecture: A Comprehensive Guide<a hidden class=anchor aria-hidden=true href=#understanding-medallion-architecture-a-comprehensive-guide>#</a></h1><p>In today’s data-driven world, organizations face the challenge of managing vast volumes of diverse data coming from multiple sources. The <strong>Medallion Architecture</strong> offers a structured way to tackle this challenge by organizing data into layered stages, gradually refining it from its raw form to a business-ready state. Often referred to as a <em>multi-hop architecture</em>, this pattern is especially popular in modern data lakehouse environments where the flexibility of a data lake meets the reliability of a data warehouse.</p><p>In this post, we will explore the key concepts of Medallion Architecture, explain each layer in detail, and discuss where and how it can be applied.</p><hr><h2 id=what-is-medallion-architecture>What Is Medallion Architecture?<a hidden class=anchor aria-hidden=true href=#what-is-medallion-architecture>#</a></h2><p>Medallion Architecture is a data design pattern that organizes data processing into multiple, logical layers. The goal is to incrementally improve data quality and structure as data flows through these layers. The three primary layers are:</p><ul><li><strong>Bronze:</strong> Raw, unfiltered data.</li><li><strong>Silver:</strong> Cleansed and conformed data.</li><li><strong>Gold:</strong> Aggregated, business-level data ready for consumption.</li></ul><p>By separating the data processing pipeline into these layers, organizations can ensure robust data governance, maintain auditability, and support both exploratory analytics and mission-critical reporting.</p><hr><h2 id=the-layers-of-medallion-architecture>The Layers of Medallion Architecture<a hidden class=anchor aria-hidden=true href=#the-layers-of-medallion-architecture>#</a></h2><h3 id=bronze-layer-the-raw-data-zone>Bronze Layer: The Raw Data Zone<a hidden class=anchor aria-hidden=true href=#bronze-layer-the-raw-data-zone>#</a></h3><p>The <strong>Bronze layer</strong> is the foundation of the Medallion Architecture. Here, data is ingested from various external sources and stored in its original, unaltered format. Key characteristics include:</p><ul><li><strong>Raw Ingestion:</strong> Data is captured as-is (e.g., CSV files, JSON logs, streaming data).</li><li><strong>Metadata Enrichment:</strong> Additional columns, such as load timestamp, source ID, or processing status, are often added.</li><li><strong>Historical Archive:</strong> Since no major transformations are applied, this layer serves as a robust archive for data lineage and reprocessing.</li></ul><p><em>Example Use Case:</em><br>A retail company collects transaction logs from multiple point-of-sale systems. These logs are loaded into the Bronze layer to preserve the exact state of the data as received, ensuring that every detail is available for auditing or troubleshooting.</p><hr><h3 id=silver-layer-cleansing-and-conforming>Silver Layer: Cleansing and Conforming<a hidden class=anchor aria-hidden=true href=#silver-layer-cleansing-and-conforming>#</a></h3><p>Once raw data is stored, it needs to be cleaned and standardized. The <strong>Silver layer</strong> takes data from the Bronze layer and applies a series of transformations to:</p><ul><li><strong>Cleanse Data:</strong> Remove duplicates, filter out corrupt records, and handle missing values.</li><li><strong>Standardize Formats:</strong> Convert data into a consistent schema and format.</li><li><strong>Integrate Multiple Sources:</strong> Merge and reconcile data from different sources to create a unified view.</li></ul><p><em>Example Use Case:</em><br>Continuing with the retail example, data from different stores is merged and cleansed in the Silver layer. Customer records are deduplicated, and inconsistencies (such as varying date formats) are resolved, resulting in a consistent view of transactions and customer interactions.</p><p><em>Sample Transformation Code (PySpark):</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Read raw data from Bronze layer</span>
</span></span><span style=display:flex><span>bronze_df <span style=color:#f92672>=</span> spark<span style=color:#f92672>.</span>read<span style=color:#f92672>.</span>format(<span style=color:#e6db74>&#34;delta&#34;</span>)<span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#34;/lake/bronze/transactions&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Cleanse and standardize data for the Silver layer</span>
</span></span><span style=display:flex><span>silver_df <span style=color:#f92672>=</span> bronze_df<span style=color:#f92672>.</span>filter(<span style=color:#e6db74>&#34;amount IS NOT NULL&#34;</span>) \
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>withColumn(<span style=color:#e6db74>&#34;transaction_date&#34;</span>, to_date(col(<span style=color:#e6db74>&#34;transaction_date&#34;</span>), <span style=color:#e6db74>&#34;MM-dd-yyyy&#34;</span>)) \
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>dropDuplicates([<span style=color:#e6db74>&#34;transaction_id&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Write the cleansed data to the Silver layer</span>
</span></span><span style=display:flex><span>silver_df<span style=color:#f92672>.</span>write<span style=color:#f92672>.</span>format(<span style=color:#e6db74>&#34;delta&#34;</span>)<span style=color:#f92672>.</span>mode(<span style=color:#e6db74>&#34;overwrite&#34;</span>)<span style=color:#f92672>.</span>save(<span style=color:#e6db74>&#34;/lake/silver/transactions&#34;</span>)
</span></span></code></pre></div><hr><h3 id=gold-layer-business-ready-aggregated-data>Gold Layer: Business-Ready Aggregated Data<a hidden class=anchor aria-hidden=true href=#gold-layer-business-ready-aggregated-data>#</a></h3><p>The final stage in the Medallion Architecture is the <strong>Gold layer</strong>, where data is further refined and optimized for direct business consumption. This layer focuses on:</p><ul><li><strong>Aggregation and Enrichment:</strong> Applying business logic, creating summary tables, and performing complex calculations.</li><li><strong>Optimized for Analytics:</strong> Data models in the Gold layer are often denormalized (e.g., star schema) for fast query performance.</li><li><strong>Tailored Views:</strong> The data is arranged to serve specific use cases like dashboards, reporting, and machine learning applications.</li></ul><p><em>Example Use Case:</em><br>In the retail scenario, the Gold layer could consist of sales summaries by region, time-period, or product category. Business users and analysts can directly query these tables to generate KPIs and performance reports without worrying about the underlying data complexities.</p><p><em>Sample Aggregation Code (SQL):</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- Create a Gold table for aggregated sales metrics
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> gold_sales_summary <span style=color:#66d9ef>AS</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> 
</span></span><span style=display:flex><span>    store_id,
</span></span><span style=display:flex><span>    date(transaction_date) <span style=color:#66d9ef>as</span> sale_date,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>SUM</span>(amount) <span style=color:#66d9ef>as</span> total_sales,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>COUNT</span>(transaction_id) <span style=color:#66d9ef>as</span> transactions_count
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> silver.transactions
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> store_id, date(transaction_date);
</span></span></code></pre></div><hr><h2 id=where-can-medallion-architecture-be-applied>Where Can Medallion Architecture Be Applied?<a hidden class=anchor aria-hidden=true href=#where-can-medallion-architecture-be-applied>#</a></h2><p>Medallion Architecture is versatile and can be applied in various scenarios, including:</p><ul><li><strong>Data Lakehouses:</strong> Combining the scalability of data lakes with the reliability of data warehouses.</li><li><strong>Business Intelligence (BI):</strong> Providing clean, aggregated data for dashboards and reports.</li><li><strong>Machine Learning:</strong> Supplying high-quality, processed data to train robust ML models.</li><li><strong>Data Warehousing:</strong> Structuring ETL/ELT pipelines to support operational and analytical workloads.</li><li><strong>Data Governance:</strong> Enhancing traceability, auditability, and data quality across the organization.</li></ul><hr><h2 id=key-principles-and-benefits>Key Principles and Benefits<a hidden class=anchor aria-hidden=true href=#key-principles-and-benefits>#</a></h2><ul><li><strong>Incremental Data Refinement:</strong> Each layer builds upon the previous one, progressively enhancing data quality.</li><li><strong>Data Governance and Auditability:</strong> Keeping raw data intact in the Bronze layer ensures that data lineage and historical context are preserved.</li><li><strong>Scalability and Flexibility:</strong> Independent layers allow teams to scale processing and storage as needed, accommodating both batch and streaming data.</li><li><strong>Performance Optimization:</strong> The Gold layer’s design—often using star schema or other optimized data models—ensures fast query performance for business users.</li><li><strong>Single Source of Truth:</strong> Consistent data across layers builds trust and supports informed decision-making.</li></ul><hr><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Medallion Architecture offers a clear and methodical framework for managing the data lifecycle—from raw ingestion to refined, business-ready analytics. By leveraging the Bronze, Silver, and Gold layers, organizations can ensure that data remains accurate, auditable, and scalable. Whether you’re building a data lakehouse, designing a data warehouse, or implementing a BI solution, adopting this layered approach can simplify your data pipelines and enhance overall data quality.</p><p>Have you implemented Medallion Architecture in your projects?</p><p>Happy Data Engineering!</p><pre tabindex=0><code></code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://priya.se/tags/medallion-architecture/>Medallion Architecture</a></li><li><a href=https://priya.se/tags/data-lakehouse/>Data Lakehouse</a></li><li><a href=https://priya.se/tags/data-engineering/>Data Engineering</a></li><li><a href=https://priya.se/tags/etl/>ETL</a></li><li><a href=https://priya.se/tags/data-quality/>Data Quality</a></li><li><a href=https://priya.se/tags/hugo-blog/>Hugo Blog</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://priya.se/>Priyanka Yelluru</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>